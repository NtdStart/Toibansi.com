{"version":3,"sources":["../../src/socket/index.js"],"names":["config","require","ioEvents","io","of","on","socket","title","roomId","request","session","passport","message","broadcast","to","emit","init","app","server","Server","set","use","next","module","exports"],"mappings":"AAAA;;AACA,IAAIA,SAAUC,QAAQ,WAAR,CAAd;;AAEA;;;;AAIA,IAAIC,WAAW,SAAXA,QAAW,CAASC,EAAT,EAAa;;AAE3B;AACAA,IAAGC,EAAH,CAAM,QAAN,EAAgBC,EAAhB,CAAmB,YAAnB,EAAiC,UAASC,MAAT,EAAiB;AACjD;AACAA,SAAOD,EAAP,CAAU,YAAV,EAAwB,UAASE,KAAT,EAAgB,CACvC,CADD;AAEA,EAJD;;AAMA;AACAJ,IAAGC,EAAH,CAAM,WAAN,EAAmBC,EAAnB,CAAsB,YAAtB,EAAoC,UAASC,MAAT,EAAiB;AACpD;AACAA,SAAOD,EAAP,CAAU,MAAV,EAAkB,UAASG,MAAT,EAAiB,CAClC,CADD;AAEA;AACAF,SAAOD,EAAP,CAAU,YAAV,EAAwB,YAAW;AAClC;AACA,OAAGC,OAAOG,OAAP,CAAeC,OAAf,CAAuBC,QAAvB,IAAmC,IAAtC,EAA2C;AAC1C;AACA;AACD;AACA;AACA,GAPD;;AASA;AACAL,SAAOD,EAAP,CAAU,YAAV,EAAwB,UAASG,MAAT,EAAiBI,OAAjB,EAA0B;AACjD;AACA;AACA;AACAN,UAAOO,SAAP,CAAiBC,EAAjB,CAAoBN,MAApB,EAA4BO,IAA5B,CAAiC,YAAjC,EAA+CH,OAA/C;AACA,GALD;AAOA,EAtBD;AAuBA,CAjCD;;AAmCA;;;;;AAKA,IAAII,OAAO,SAAPA,IAAO,CAASC,GAAT,EAAa;;AAEvB,KAAIC,SAAUjB,QAAQ,MAAR,EAAgBkB,MAAhB,CAAuBF,GAAvB,CAAd;AACA,KAAId,KAAOF,QAAQ,WAAR,EAAqBiB,MAArB,CAAX;;AAEA;AACAf,IAAGiB,GAAH,CAAO,YAAP,EAAqB,CAAC,WAAD,CAArB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACAjB,IAAGkB,GAAH,CAAO,UAACf,MAAD,EAASgB,IAAT,EAAkB;AACxBrB,UAAQ,YAAR,EAAsBK,OAAOG,OAA7B,EAAsC,EAAtC,EAA0Ca,IAA1C;AACA,EAFD;;AAIA;AACApB,UAASC,EAAT;;AAEA;AACA,QAAOe,MAAP;AACA,CA1BD;;AA4BAK,OAAOC,OAAP,GAAiBR,IAAjB","file":"index.js","sourcesContent":["'use strict';\r\nvar config \t= require('../config');\r\n\r\n/**\r\n * Encapsulates all code for emitting and listening to socket events\r\n *\r\n */\r\nvar ioEvents = function(io) {\r\n\r\n\t// Rooms namespace\r\n\tio.of('/rooms').on('connection', function(socket) {\r\n\t\t// Create a new room\r\n\t\tsocket.on('createRoom', function(title) {\r\n\t\t});\r\n\t});\r\n\r\n\t// Chatroom namespace\r\n\tio.of('/chatroom').on('connection', function(socket) {\r\n\t\t// Join a chatroom\r\n\t\tsocket.on('join', function(roomId) {\r\n\t\t});\r\n\t\t// When a socket exits\r\n\t\tsocket.on('disconnect', function() {\r\n\t\t\t// Check if user exists in the session\r\n\t\t\tif(socket.request.session.passport == null){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Find the room to which the socket is connected to,\r\n\t\t\t// and remove the current user + socket from this room\r\n\t\t});\r\n\r\n\t\t// When a new message arrives\r\n\t\tsocket.on('newMessage', function(roomId, message) {\r\n\t\t\t// No need to emit 'addMessage' to the current socket\r\n\t\t\t// As the new message will be added manually in 'main.js' file\r\n\t\t\t// socket.emit('addMessage', message);\r\n\t\t\tsocket.broadcast.to(roomId).emit('addMessage', message);\r\n\t\t});\r\n\r\n\t});\r\n}\r\n\r\n/**\r\n * Initialize Socket.io\r\n * Uses Redis as Adapter for Socket.io\r\n *\r\n */\r\nvar init = function(app){\r\n\r\n\tvar server \t= require('http').Server(app);\r\n\tvar io \t\t= require('socket.io')(server);\r\n\r\n\t// Force Socket.io to ONLY use \"websockets\"; No Long Polling.\r\n\tio.set('transports', ['websocket']);\r\n\r\n\t// Using Redis\r\n\t// let port = config.redis.port;\r\n\t// let host = config.redis.host;\r\n\t// let password = config.redis.password;\r\n\t// let pubClient = redis(port, host, { auth_pass: password });\r\n\t// let subClient = redis(port, host, { auth_pass: password, return_buffers: true, });\r\n\t// io.adapter(adapter({ pubClient, subClient }));\r\n\r\n\t// Allow sockets to access session data\r\n\tio.use((socket, next) => {\r\n\t\trequire('../session')(socket.request, {}, next);\r\n\t});\r\n\r\n\t// Define all Events\r\n\tioEvents(io);\r\n\r\n\t// The server object will be then used to list to a port number\r\n\treturn server;\r\n}\r\n\r\nmodule.exports = init;"]}